{
    "skill_folder_name": "variable_weighting",
    "skill_md_content": "---\nname: 变量定权方法\ndescription: 这是一种为多个评价变量确定权重的数学建模方法，常用于综合评价、多准则决策、绩效评估等场景，通过量化各变量对目标的重要性程度，提升评价结果的科学性与合理性。\nauthor: Doubao-1.8\nversion: 1.0.0\ntrigger: 当需要为多个评价指标、决策变量或影响因子确定权重时触发，例如：综合评价体系构建、多方案决策排序、绩效指标权重分配等场景。\noutput_format: 返回包含各变量名称与对应权重的字典或Pandas Series，支持层次分析法(AHP)、熵权法、变异系数法三种主流计算方法。\n---\n\n## 工作流程\n1. **需求分析**：明确评价目标与待赋权的变量集合，确定变量类型（定性/定量）。\n2. **方法选择**：根据变量类型与数据情况选择合适的权重计算方法：\n   - 若变量多为定性或依赖专家经验，选择层次分析法(AHP)；\n   - 若有充足的定量样本数据且需客观权重，选择熵权法；\n   - 若需反映变量离散程度对权重的影响，选择变异系数法。\n3. **数据准备**：\n   - AHP：构建专家判断矩阵（需满足互反性）；\n   - 熵权法/变异系数法：收集或预处理样本数据（如去除异常值、标准化）。\n4. **权重计算**：调用本技能的实现工具完成权重计算。\n5. **结果验证**：检查权重的合理性（如AHP的一致性检验、权重和为1等），必要时调整方法或数据。\n6. **结果应用**：将计算得到的权重用于综合评价或决策分析。\n\n## 约束条件\n1. **数据要求**：\n   - AHP：判断矩阵需为正互反矩阵，且一致性比率(CR)需小于0.1（否则需调整判断矩阵）；\n   - 熵权法/变异系数法：样本数据需为非负定量数据，且每个变量的取值不能完全相同（否则无法计算有效权重）。\n2. **方法适用性**：\n   - AHP适合定性指标占比高、依赖专家经验的场景，但主观性较强；\n   - 熵权法适合定量数据充足的场景，权重结果更客观，但无法体现专家经验；\n   - 变异系数法适合关注变量离散程度的场景，计算简单但忽略变量间的相关性。\n3. **结果限制**：权重仅反映变量的相对重要性，需结合业务场景进行合理性分析，不可直接作为绝对依据。\n\n## 工具使用\n本技能的Python实现位于`scripts/model.py`，提供了三种常用的变量定权方法：\n- `ahp_weight(judgment_matrix)`：层次分析法，输入专家判断矩阵，返回权重与一致性检验结果；\n- `entropy_weight(data_df)`：熵权法，输入样本数据DataFrame（行：样本，列：变量），返回各变量的客观权重；\n- `coefficient_of_variation_weight(data_df)`：变异系数法，输入样本数据DataFrame，返回基于离散程度的权重。\n可直接调用上述函数完成变量权重的计算。",
    "python_code": "import numpy as np\nimport pandas as pd\nfrom scipy.linalg import eig\n\ndef ahp_weight(judgment_matrix):\n    \"\"\"\n    层次分析法计算变量权重\n    参数:\n        judgment_matrix: np.ndarray - 正互反判断矩阵，形状为(n, n)，n为变量个数\n    返回:\n        dict - 包含\"weights\"（权重列表）和\"consistency_ratio\"（一致性比率）的字典\n    异常:\n        ValueError - 若判断矩阵非方阵、非正矩阵或一致性不满足要求\n    \"\"\"\n    n = judgment_matrix.shape[0]\n    if judgment_matrix.shape[1] != n:\n        raise ValueError(\"判断矩阵必须为方阵\")\n    if np.any(judgment_matrix <= 0):\n        raise ValueError(\"判断矩阵元素必须为正数\")\n    \n    eigenvalues, eigenvectors = eig(judgment_matrix)\n    max_eigen_idx = np.argmax(eigenvalues.real)\n    max_eigenvalue = eigenvalues[max_eigen_idx].real\n    eigenvector = eigenvectors[:, max_eigen_idx].real\n    \n    weights = eigenvector / np.sum(eigenvector)\n    ci = (max_eigenvalue - n) / (n - 1)\n    \n    ri_values = {1:0,2:0,3:0.58,4:0.90,5:1.12,6:1.24,7:1.32,8:1.41,9:1.45,10:1.49}\n    if n not in ri_values:\n        raise ValueError(\"变量个数需在1-10之间\")\n    ri = ri_values[n]\n    cr = ci / ri if ri != 0 else 0.0\n    \n    if cr > 0.1 and n >=3:\n        raise ValueError(f\"一致性比率CR={cr:.4f} > 0.1，判断矩阵一致性不满足要求，请调整矩阵\")\n    \n    return {\"weights\": [round(w,4) for w in weights.tolist()], \"consistency_ratio\": round(cr,4)}\n\n\ndef entropy_weight(data_df):\n    \"\"\"\n    熵权法计算变量的客观权重\n    参数:\n        data_df: pd.DataFrame - 样本数据，行表示样本，列表示变量，数值需为非负\n    返回:\n        pd.Series - 各变量的权重，索引为变量名称\n    异常:\n        ValueError - 若数据包含负值、某变量取值全相同\n    \"\"\"\n    if (data_df < 0).any().any():\n        raise ValueError(\"数据中存在负值，无法进行熵权法计算\")\n    \n    data = data_df.values\n    data = data + 1e-10  # 避免0值导致对数错误\n    p = data / np.sum(data, axis=0)\n    \n    n_samples = data.shape[0]\n    k = 1 / np.log(n_samples) if n_samples >1 else 1.0\n    entropy = -k * np.sum(p * np.log(p), axis=0)\n    diversity = 1 - entropy\n    weights = diversity / np.sum(diversity)\n    \n    return pd.Series(weights, index=data_df.columns, name=\"权重\").round(4)\n\n\ndef coefficient_of_variation_weight(data_df):\n    \"\"\"\n    变异系数法计算变量权重\n    参数:\n        data_df: pd.DataFrame - 样本数据，行表示样本，列表示变量，数值需为非负且均值不为0\n    返回:\n        pd.Series - 各变量的权重，索引为变量名称\n    异常:\n        ValueError - 若数据包含负值、某变量均值为0\n    \"\"\"\n    if (data_df <0).any().any():\n        raise ValueError(\"数据中存在负值，无法进行变异系数法计算\")\n    \n    mean_vals = data_df.mean(axis=0)\n    if (mean_vals ==0).any():\n        raise ValueError(\"存在变量均值为0，无法计算变异系数\")\n    \n    std_vals = data_df.std(axis=0, ddof=0)\n    cv = std_vals / mean_vals\n    weights = cv / np.sum(cv)\n    \n    return pd.Series(weights, index=data_df.columns, name=\"权重\").round(4)",
    "requirements": [
        "numpy",
        "pandas",
        "scipy"
    ],
    "examples_md_content": "# 变量定权方法使用示例\n\n## 示例1：层次分析法(AHP)\n### 输入\n```python\nimport numpy as np\njudgment_matrix = np.array([\n    [1, 2, 3],\n    [1/2, 1, 2],\n    [1/3, 1/2, 1]\n])\n```\n### 调用\n```python\nfrom scripts.model import ahp_weight\nresult = ahp_weight(judgment_matrix)\n```\n### 预期输出\n```json\n{\n    \"weights\": [0.5396, 0.2970, 0.1634],\n    \"consistency_ratio\": 0.0180\n}\n```\n### 说明\n一致性比率CR=0.0180 < 0.1，满足一致性要求，权重和为1。\n\n## 示例2：熵权法\n### 输入\n```python\nimport pandas as pd\ndata = pd.DataFrame({\n    \"变量A\": [80, 90, 75, 85],\n    \"变量B\": [70, 85, 65, 90],\n    \"变量C\": [95, 80, 85, 70]\n})\n```\n### 调用\n```python\nfrom scripts.model import entropy_weight\nresult = entropy_weight(data)\n```\n### 预期输出\n```\n变量A    0.3282\n变量B    0.3421\n变量C    0.3297\nName: 权重, dtype: float64\n```\n### 说明\n各变量权重反映了其信息熵差异，权重和为1。\n\n## 示例3：变异系数法\n### 输入\n```python\nimport pandas as pd\ndata = pd.DataFrame({\n    \"变量X\": [10,20,15,25,30],\n    \"变量Y\": [5,10,7,12,15],\n    \"变量Z\": [20,22,19,21,23]\n})\n```\n### 调用\n```python\nfrom scripts.model import coefficient_of_variation_weight\nresult = coefficient_of_variation_weight(data)\n```\n### 预期输出\n```\n变量X    0.4464\n变量Y    0.4464\n变量Z    0.1072\nName: 权重, dtype: float64\n```\n### 说明\n变量X、Y离散程度高权重较大，变量Z离散程度低权重较小，权重和为1。"
}