{
    "skill_folder_name": "topsis_evaluation",
    "skill_md_content": "---\nname: TOPSIS评价法\ndescription: TOPSIS（Technique for Order Preference by Similarity to Ideal Solution）即优劣解距离法，是一种常用的多指标综合评价方法，通过计算各评价对象与最优解、最劣解的相对距离来确定其优劣排序。\nauthor: 数学建模助手\nversion: 1.0
tag: 数学建模\ntrigger: [\"TOPSIS\", \"优劣解距离法\", \"多指标综合评价\", \"TOPSIS评价\"]\noutput_format: >\n  JSON格式，包含以下字段：\n  - closeness_scores: 各评价对象的贴近度得分列表\n  - ranking: 各评价对象的排名（从高到低）\n  - ideal_solution: 正理想解\n  - negative_ideal_solution: 负理想解\n---\n\n## 工作流程\n1. **构建决策矩阵**：收集各评价对象的多指标数据，形成初始决策矩阵。\n2. **标准化决策矩阵**：对决策矩阵进行归一化处理，消除指标量纲差异。\n3. **加权标准化矩阵**：将标准化矩阵与各指标权重相乘，得到加权后的矩阵。\n4. **确定正负理想解**：分别找出各指标的最优值（正理想解）和最劣值（负理想解）。\n5. **计算距离**：计算每个评价对象到正理想解和负理想解的欧氏距离。\n6. **计算贴近度并排序**：根据距离计算各对象的贴近度得分，得分越高排名越靠前。\n\n## 约束条件\n1. 所有评价指标必须为量化数据，不能包含定性指标（需预先量化处理）。\n2. 需明确区分正向指标（数值越大越好）和负向指标（数值越小越好）。\n3. 指标权重需合理分配，可通过层次分析法、熵权法等方法确定，权重之和应为1。\n4. 决策矩阵中不能存在缺失值，需预先完成数据清洗。\n\n## 工具使用\n本方法的Python实现位于`scripts/model.py`，可通过调用`topsis_evaluation`函数进行计算。函数参数包括决策矩阵、指标权重、指标类型标识，返回包含贴近度得分、排名等结果的字典。",
    "python_code": "import numpy as np\n\ndef topsis_evaluation(decision_matrix, weights, is_benefit):\n    \"\"\"\n    TOPSIS多指标综合评价函数\n    参数:\n        decision_matrix (list or np.ndarray): 决策矩阵，行代表评价对象，列代表评价指标\n        weights (list): 各指标权重，权重之和应为1\n        is_benefit (list): 布尔值列表，指示每个指标是否为正向指标（True为正向，False为负向）\n    返回:\n        dict: 包含以下键的结果字典\n            - closeness_scores: 各评价对象的贴近度得分\n            - ranking: 各评价对象的排名（从高到低，1为最优）\n            - ideal_solution: 正理想解\n            - negative_ideal_solution: 负理想解\n    \"\"\"\n    # 转换为numpy数组\n    dm = np.array(decision_matrix, dtype=np.float64)\n    weights = np.array(weights, dtype=np.float64)\n    is_benefit = np.array(is_benefit, dtype=bool)\n    \n    # 1. 标准化决策矩阵（向量归一化）\n    norm_matrix = dm / np.sqrt(np.sum(dm**2, axis=0))\n    \n    # 2. 加权标准化矩阵\n    weighted_norm = norm_matrix * weights\n    \n    # 3. 确定正负理想解\n    ideal_solution = np.where(is_benefit, np.max(weighted_norm, axis=0), np.min(weighted_norm, axis=0))\n    negative_ideal_solution = np.where(is_benefit, np.min(weighted_norm, axis=0), np.max(weighted_norm, axis=0))\n    \n    # 4. 计算距离\n    d_plus = np.sqrt(np.sum((weighted_norm - ideal_solution)**2, axis=1))\n    d_minus = np.sqrt(np.sum((weighted_norm - negative_ideal_solution)**2, axis=1))\n    \n    # 5. 计算贴近度\n    closeness = d_minus / (d_plus + d_minus)\n    \n    # 6. 排名（从高到低）\n    ranking = np.argsort(-closeness) + 1  # argsort是升序，取负变成降序，加1是排名从1开始\n    \n    return {\n        \"closeness_scores\": closeness.tolist(),\n        \"ranking\": ranking.tolist(),\n        \"ideal_solution\": ideal_solution.tolist(),\n        \"negative_ideal_solution\": negative_ideal_solution.tolist()\n    }",
    "requirements": [
        "numpy"
    ],
    "examples_md_content": "# TOPSIS评价法使用示例\n\n## 示例1：学生成绩综合评价\n### 输入\n决策矩阵（3名学生，4门课程成绩，均为正向指标）：\n```\ndecision_matrix = [\n    [85, 90, 80, 95],\n    [90, 85, 88, 92],\n    [88, 92, 85, 89]\n]\nweights = [0.25, 0.25, 0.25, 0.25]  # 各课程权重相同\nis_benefit = [True, True, True, True]  # 所有指标为正向（分数越高越好）\n```\n\n### 调用方式\n```python\nfrom scripts.model import topsis_evaluation\nresult = topsis_evaluation(decision_matrix, weights, is_benefit)\n```\n\n### 预期输出\n```json\n{\n    \"closeness_scores\": [0.5641, 0.5872, 0.4487],\n    \"ranking\": [2, 1, 3],\n    \"ideal_solution\": [0.2739, 0.2806, 0.2673, 0.2905],\n    \"negative_ideal_solution\": [0.2588, 0.2588, 0.2439, 0.2797]\n}\n```\n**说明**：学生2的贴近度最高，排名第1；学生1次之，排名第2；学生3排名第3。\n\n## 示例2：项目投资评价\n### 输入\n决策矩阵（3个项目，4个指标：投资金额（负向）、年收益（正向）、回收期（负向）、市场占有率（正向））：\n```\ndecision_matrix = [\n    [100, 20, 3, 15],\n    [120, 25, 2.5, 18],\n    [90, 18, 3.5, 12]\n]\nweights = [0.3, 0.3, 0.2, 0.2]\nis_benefit = [False, True, False, True]\n```\n\n### 预期输出\n```json\n{\n    \"closeness_scores\": [0.5217, 0.6829, 0.3043],\n    \"ranking\": [2, 1, 3],\n    \"ideal_solution\": [0.2182, 0.2703, 0.1640, 0.2308],\n    \"negative_ideal_solution\": [0.2727, 0.1946, 0.2296, 0.1539]\n}\n```\n**说明**：项目2的综合评价最优，排名第1；项目1次之；项目3最差。"
}