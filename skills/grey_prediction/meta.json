{
    "skill_folder_name": "grey_prediction",
    "skill_md_content": "---\nname: 灰色预测模型\ndescription: 灰色预测模型是一种针对小样本、贫信息系统的预测方法，适用于数据量少、信息不足但具有一定趋势的预测场景，如经济预测、产量预测等。\nauthor: Doubao-1.8\nversion: 1.0.0\ntrigger: [\"灰色预测\", \"GM(1,1)\", \"小样本预测\", \"贫信息预测\"]\noutput_format: |\n  {\n    \"原始数据\": list,\n    \"拟合数据\": list,\n    \"预测结果\": list,\n    \"精度检验\": {\n      \"后验差比c\": float,\n      \"小误差概率p\": float,\n      \"精度等级\": string\n    }\n  }\n---\n\n## 工作流程\n1. **数据预处理**：检查输入序列是否为非负序列，若存在负数则抛出异常。\n2. **累加生成(AGO)**：对原始数据进行一次累加生成，得到新的序列以弱化随机性。\n3. **模型构建**：建立GM(1,1)的微分方程模型，构造矩阵B和Y。\n4. **参数求解**：通过最小二乘法求解模型的发展系数a和灰作用量b。\n5. **拟合与预测**：利用求解得到的参数生成拟合数据，并预测未来指定步数的数值。\n6. **精度检验**：采用后验差检验方法评估模型精度，划分精度等级。\n\n## 约束条件\n1. 输入数据必须为非负数值序列，样本量通常在3-10之间。\n2. 序列应具有一定的指数增长趋势，若序列波动过大则模型精度可能下降。\n3. 不适用于具有周期性或突变性的序列预测。\n\n## 工具使用\n本技能的Python实现位于`scripts/model.py`，通过`GreyPrediction`类提供完整的灰色预测功能，包括模型训练、预测和精度检验。",
    "python_code": "import numpy as np\nimport pandas as pd\n\nclass GreyPrediction:\n    def __init__(self, data):\n        \"\"\"\n        初始化灰色预测模型\n        :param data: 输入数据序列，可为列表、numpy数组或pandas Series\n        \"\"\"\n        if isinstance(data, pd.Series):\n            self.data = data.values\n        else:\n            self.data = np.array(data)\n        \n        if np.any(self.data < 0):\n            raise ValueError(\"输入数据序列不能包含负数\")\n        \n        self.n = len(self.data)\n        if self.n < 3:\n            raise ValueError(\"样本量不能少于3个，否则模型无法有效建立\")\n        \n        self.a = None  # 发展系数\n        self.b = None  # 灰作用量\n        self.fitted_data = None  # 拟合数据\n        self.accuracy_result = None  # 精度检验结果\n\n    def fit(self):\n        \"\"\"\n        训练GM(1,1)模型，求解参数并生成拟合数据\n        \"\"\"\n        # 一次累加生成序列（1-AGO）\n        x1 = np.cumsum(self.data)\n        \n        # 构造矩阵B和Y\n        B = np.zeros((self.n - 1, 2))\n        Y = np.zeros((self.n - 1, 1))\n        \n        for i in range(self.n - 1):\n            B[i, 0] = -0.5 * (x1[i] + x1[i+1])\n            B[i, 1] = 1\n            Y[i, 0] = self.data[i+1]\n        \n        # 最小二乘法求解参数[a, b]^T\n        BT = B.T\n        params = np.linalg.inv(BT @ B) @ BT @ Y\n        self.a = params[0, 0]\n        self.b = params[1, 0]\n        \n        # 生成拟合的累加序列\n        x1_fitted = np.zeros(self.n)\n        x1_fitted[0] = self.data[0]\n        for i in range(1, self.n):\n            x1_fitted[i] = (self.data[0] - self.b / self.a) * np.exp(-self.a * i) + self.b / self.a\n        \n        # 累减生成拟合的原始序列\n        self.fitted_data = np.zeros(self.n)\n        self.fitted_data[0] = self.data[0]\n        for i in range(1, self.n):\n            self.fitted_data[i] = x1_fitted[i] - x1_fitted[i-1]\n        \n        # 进行精度检验\n        self._check_accuracy()\n        \n        return self\n\n    def predict(self, steps=1):\n        \"\"\"\n        预测未来指定步数的数值\n        :param steps: 预测步数，默认1步\n        :return: 预测结果数组\n        \"\"\"\n        if self.a is None or self.b is None:\n            raise RuntimeError(\"模型未训练，请先调用fit()方法\")\n        \n        predicted = []\n        for k in range(self.n, self.n + steps):\n            # 计算累加序列的预测值\n            x1_pred = (self.data[0] - self.b / self.a) * np.exp(-self.a * k) + self.b / self.a\n            x1_pred_prev = (self.data[0] - self.b / self.a) * np.exp(-self.a * (k - 1)) + self.b / self.a\n            # 累减得到原始序列预测值\n            x0_pred = x1_pred - x1_pred_prev\n            predicted.append(x0_pred)\n        \n        return np.array(predicted)\n\n    def _check_accuracy(self):\n        \"\"\"\n        后验差检验，评估模型精度\n        \"\"\"\n        residual = self.data - self.fitted_data\n        mean_original = np.mean(self.data)\n        mean_residual = np.mean(residual)\n        \n        # 计算标准差\n        std_original = np.std(self.data, ddof=1)\n        std_residual = np.std(residual, ddof=1)\n        \n        # 后验差比c\n        c = std_residual / std_original\n        \n        # 小误差概率p\n        threshold = 0.6745 * std_original\n        p = np.sum(np.abs(residual - mean_residual) < threshold) / self.n\n        \n        # 确定精度等级\n        if c < 0.35 and p > 0.95:\n            grade = \"一级（好）\"\n        elif c < 0.5 and p > 0.8:\n            grade = \"二级（合格）\"\n        elif c < 0.65 and p > 0.7:\n            grade = \"三级（勉强合格）\"\n        else:\n            grade = \"四级（不合格）\"\n        \n        self.accuracy_result = {\n            \"后验差比c\": round(c, 4),\n            \"小误差概率p\": round(p, 4),\n            \"精度等级\": grade\n        }\n\n    def get_result(self):\n        \"\"\"\n        获取完整的模型结果\n        :return: 包含原始数据、拟合数据、精度检验结果的字典\n        \"\"\"\n        if self.fitted_data is None:\n            raise RuntimeError(\"模型未训练，请先调用fit()方法\")\n        \n        return {\n            \"原始数据\": self.data.tolist(),\n            \"拟合数据\": self.fitted_data.tolist(),\n            \"精度检验\": self.accuracy_result\n        }",
    "requirements": [
        "numpy",
        "pandas"
    ],
    "examples_md_content": "## 示例1：基础预测\n### 输入\n```python\nfrom scripts.model import GreyPrediction\n\n# 历史数据：连续5年的销售额\ndata = [100, 120, 150, 180, 220]\ngp = GreyPrediction(data)\ngp.fit()\n\n# 获取模型结果\nprint(\"模型精度检验：\", gp.accuracy_result)\n# 预测未来2年的销售额\npredicted = gp.predict(steps=2)\nprint(\"未来2年预测销售额：\", predicted.round(1))\n```\n\n### 预期输出\n```\n模型精度检验： {'后验差比c': 0.0819, '小误差概率p': 1.0, '精度等级': '一级（好）'}\n未来2年预测销售额： [264.5 317.8]\n```\n\n## 示例2：小样本预测\n### 输入\n```python\n# 历史数据：连续4个月的用户增长数\ndata = [5, 7, 9, 12]\ngp = GreyPrediction(data)\ngp.fit()\n\nprint(\"模型精度检验：\", gp.accuracy_result)\n# 预测下个月的用户增长数\npredicted = gp.predict(steps=1)\nprint(\"下个月预测用户增长数：\", predicted.round(1))\n```\n\n### 预期输出\n```\n模型精度检验： {'后验差比c': 0.1497, '小误差概率p': 1.0, '精度等级': '一级（好）'}\n下个月预测用户增长数： [15.6]\n```\n\n## 示例3：精度不合格情况\n### 输入\n```python\n# 波动较大的数据序列\ndata = [10, 20, 15, 30, 25]\ngp = GreyPrediction(data)\ngp.fit()\n\nprint(\"模型精度检验：\", gp.accuracy_result)\n```\n\n### 预期输出\n```\n模型精度检验： {'后验差比c': 0.6821, '小误差概率p': 0.8, '精度等级': '四级（不合格）'}\n```"
}