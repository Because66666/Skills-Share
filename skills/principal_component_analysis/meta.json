{
    "skill_folder_name": "principal_component_analysis",
    "skill_md_content": "---\nname: 主成分分析（PCA）\ndescription: 主成分分析是一种常用的降维技术，通过线性变换将高维数据转换为低维数据，同时保留数据的主要方差信息，用于数据压缩、特征提取和可视化等场景。\nauthor: Doubao-1.8\nversion: 1.0
tag: 数学建模\ntrigger: 当需要对高维数据进行降维处理、提取关键特征或进行数据可视化时触发此技能。\noutput_format: 包含降维后的数据、主成分方差贡献率、累计方差贡献率等结果的字典或DataFrame。\n---\n\n## 工作流程\n1. 数据预处理：对输入数据进行标准化或归一化处理，确保各特征尺度一致。\n2. 计算协方差矩阵：基于预处理后的数据计算协方差矩阵，反映特征间的线性相关程度。\n3. 求解特征值与特征向量：对协方差矩阵进行特征分解，得到特征值和对应的特征向量。\n4. 选择主成分：根据特征值从大到小排序，选择前k个特征向量（主成分），通常根据累计方差贡献率确定k值（如累计贡献率≥85%）。\n5. 数据转换：将原始数据投影到选定的主成分上，得到降维后的数据。\n6. 结果分析：输出降维后的数据、各主成分的方差贡献率及累计贡献率，用于后续分析或可视化。\n\n## 约束条件\n- 输入数据需为数值型数据，无缺失值（或已完成缺失值处理）。\n- 数据需进行标准化处理，避免量纲差异对结果的影响。\n- 主成分的解释性可能较弱，需结合业务场景进行分析。\n- 当数据特征间线性相关性较低时，PCA降维效果可能不佳。\n\n## 工具使用\n此技能的Python实现位于 `scripts/model.py` 中，提供了封装好的PCA类，支持数据预处理、主成分选择、数据转换等功能。可通过调用类的方法完成完整的PCA分析流程，包括拟合模型、转换数据以及获取关键模型参数。",
    "python_code": "import numpy as np\nimport pandas as pd\n\nclass PCA:\n    def __init__(self, n_components=None, explained_variance_ratio_threshold=0.85):\n        \"\"\"\n        初始化PCA模型\n        参数:\n            n_components: 保留的主成分数量，若为None则根据累计方差贡献率阈值自动选择\n            explained_variance_ratio_threshold: 累计方差贡献率阈值，默认0.85\n        \"\"\"\n        self.n_components = n_components\n        self.threshold = explained_variance_ratio_threshold\n        self.mean_ = None\n        self.std_ = None\n        self.components_ = None\n        self.explained_variance_ = None\n        self.explained_variance_ratio_ = None\n        self.cumulative_variance_ratio_ = None\n\n    def fit(self, X):\n        \"\"\"\n        拟合PCA模型，计算主成分\n        参数:\n            X: 输入数据，可为numpy数组或pandas DataFrame\n        返回:\n            拟合后的模型对象\n        \"\"\"\n        # 转换为numpy数组\n        X = np.asarray(X)\n        \n        # 数据标准化\n        self.mean_ = np.mean(X, axis=0)\n        self.std_ = np.std(X, axis=0)\n        # 避免除以0的情况\n        self.std_[self.std_ == 0] = 1e-8\n        X_std = (X - self.mean_) / self.std_\n        \n        # 计算协方差矩阵\n        cov_matrix = np.cov(X_std.T)\n        \n        # 特征分解\n        eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)\n        \n        # 对特征值和特征向量按降序排序\n        sorted_indices = np.argsort(eigenvalues)[::-1]\n        sorted_eigenvalues = eigenvalues[sorted_indices]\n        sorted_eigenvectors = eigenvectors[:, sorted_indices]\n        \n        # 计算方差贡献率和累计方差贡献率\n        total_variance = np.sum(sorted_eigenvalues)\n        self.explained_variance_ratio_ = sorted_eigenvalues / total_variance\n        self.cumulative_variance_ratio_ = np.cumsum(self.explained_variance_ratio_)\n        \n        # 确定主成分数量\n        if self.n_components is None:\n            # 找到满足累计方差贡献率≥阈值的最小k\n            self.n_components = np.argmax(self.cumulative_variance_ratio_ >= self.threshold) + 1\n        \n        # 选择前n_components个主成分\n        self.components_ = sorted_eigenvectors[:, :self.n_components]\n        self.explained_variance_ = sorted_eigenvalues[:self.n_components]\n        \n        return self\n\n    def transform(self, X):\n        \"\"\"\n        将输入数据投影到主成分上，得到降维后的数据\n        参数:\n            X: 输入数据，可为numpy数组或pandas DataFrame\n        返回:\n            降维后的数据（numpy数组）\n        \"\"\"\n        if self.components_ is None:\n            raise ValueError(\"模型尚未拟合，请先调用fit方法\")\n        \n        X = np.asarray(X)\n        X_std = (X - self.mean_) / self.std_\n        X_pca = np.dot(X_std, self.components_)\n        \n        return X_pca\n\n    def fit_transform(self, X):\n        \"\"\"\n        拟合模型并同时转换数据\n        参数:\n            X: 输入数据，可为numpy数组或pandas DataFrame\n        返回:\n            降维后的数据（numpy数组）\n        \"\"\"\n        self.fit(X)\n        return self.transform(X)",
    "requirements": [
        "numpy",
        "pandas"
    ],
    "examples_md_content": "# 主成分分析（PCA）使用示例\n\n## 示例1：指定主成分数量\n### 输入数据\n```python\nimport pandas as pd\n\ndata = pd.DataFrame({\n    '特征1': [1, 2, 3, 4, 5],\n    '特征2': [2, 4, 6, 8, 10],\n    '特征3': [3, 6, 9, 12, 15]\n})\n```\n\n### 调用方式\n```python\nfrom scripts.model import PCA\n\npca = PCA(n_components=1)\nreduced_data = pca.fit_transform(data)\n```\n\n### 预期输出\n- 降维后的数据（numpy数组）：\n```\narray([-2.44948974, -0.81649658,  0.81649658,  2.44948974,  4.0824829 ])\n```\n- 主成分方差贡献率：`[1.0]`\n- 累计方差贡献率：`[1.0]`\n（说明：由于输入数据的三个特征完全线性相关，第一个主成分即可解释100%的方差）\n\n## 示例2：基于累计方差贡献率阈值自动选择主成分\n### 输入数据\n```python\nimport numpy as np\n\nnp.random.seed(42)\n# 生成100个样本，5个特征的随机数据\ndata = np.random.randn(100, 5)\n```\n\n### 调用方式\n```python\nfrom scripts.model import PCA\n\npca = PCA(explained_variance_ratio_threshold=0.85)\nreduced_data = pca.fit_transform(data)\n```\n\n### 预期输出\n- 降维后的数据形状：`(100, 4)`（实际取决于随机数据，通常前4个主成分累计方差贡献率接近或超过85%）\n- 主成分方差贡献率示例：`[0.223, 0.212, 0.201, 0.189, 0.175]`\n- 累计方差贡献率示例：`[0.223, 0.435, 0.636, 0.825, 1.0]`\n\n## 示例3：获取模型关键参数\n### 调用方式\n```python\npca = PCA(n_components=2)\npca.fit(data)\n\n# 获取主成分矩阵\ncomponents = pca.components_\n# 获取方差贡献率\nvariance_ratios = pca.explained_variance_ratio_\n# 获取累计方差贡献率\ncumulative_ratios = pca.cumulative_variance_ratio_\n```\n\n### 预期输出\n- `components`：形状为`(5, 2)`的numpy数组，每列代表一个主成分\n- `variance_ratios`：长度为2的数组，包含两个主成分的方差贡献率\n- `cumulative_ratios`：长度为2的数组，包含累计方差贡献率"
}