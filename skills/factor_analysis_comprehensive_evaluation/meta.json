{
    "skill_folder_name": "factor_analysis_comprehensive_evaluation",
    "skill_md_content": "---\nname: 因子分析综合评价法\ndescription: 一种多变量统计分析方法，通过提取公共因子简化多指标体系，结合因子方差贡献率计算综合得分，实现对评价对象的客观排序与评价\nauthor: Doubao-1.8\nversion: 1.0\ntrigger: [\"因子分析\", \"综合评价\", \"多指标评价\", \"因子得分排名\", \"公共因子提取\"]\noutput_format: >\n  JSON格式，包含适用性检验结果、因子载荷矩阵、因子方差解释、因子得分、综合得分及排名等信息\n---\n\n## 工作流程\n1. **数据预处理**：对输入的多指标数据进行标准化处理以消除量纲差异，处理缺失值（删除或插补）\n2. **适用性检验**：执行KMO检验和巴特利特球形检验，验证数据是否适合进行因子分析\n3. **公共因子提取**：通过主成分分析法或极大似然法提取公共因子，根据特征值准则确定最优因子个数\n4. **因子旋转**：采用方差最大化旋转等方法优化因子载荷矩阵，提升公共因子的可解释性\n5. **因子得分计算**：基于回归法计算每个评价对象的各公共因子得分\n6. **综合评价**：以各因子的方差贡献率为权重，计算综合得分并对评价对象进行排名\n\n## 约束条件\n- 输入数据需为连续型数值变量，不适用于分类变量\n- 样本量应满足至少为变量数的5倍，以保证分析结果的稳定性\n- 变量之间需存在一定相关性，若变量独立则不适合因子分析\n- KMO检验值应大于0.6且巴特利特球形检验P值小于0.05，否则分析效果可能较差\n\n## 工具使用\n该方法的Python实现位于`scripts/model.py`，可调用其中的`factor_analysis_comprehensive_evaluation`函数，传入评价数据集及可选参数（因子个数、旋转方法），即可获取完整的综合评价结果。",
    "python_code": "import pandas as pd\nimport numpy as np\nfrom factor_analyzer import FactorAnalyzer, calculate_kmo, calculate_bartlett_sphericity\nfrom sklearn.preprocessing import StandardScaler\n\ndef factor_analysis_comprehensive_evaluation(data, n_factors=None, rotation='varimax'):\n    \"\"\"\n    因子分析综合评价法实现\n    参数:\n        data (pd.DataFrame): 输入数据集，每行代表一个评价对象，每列代表一个评价指标\n        n_factors (int, optional): 提取的公共因子个数，若为None则根据特征值大于1自动确定\n        rotation (str, optional): 因子旋转方法，默认'varimax'（方差最大化旋转）\n    返回:\n        dict: 包含以下键的结果字典：\n            'kmo_test': KMO检验结果（统计量）\n            'bartlett_test': 巴特利特球形检验结果（卡方值、p值）\n            'factor_loadings': 因子载荷矩阵（DataFrame）\n            'factor_variance': 因子方差解释信息（方差贡献、累积方差贡献，DataFrame）\n            'factor_scores': 各样本的因子得分（DataFrame）\n            'comprehensive_scores': 各样本的综合得分（Series）\n            'ranking': 各样本的综合排名（从高到低，Series）\n    \"\"\"\n    # 1. 数据标准化\n    scaler = StandardScaler()\n    scaled_data = scaler.fit_transform(data)\n    scaled_df = pd.DataFrame(scaled_data, index=data.index, columns=data.columns)\n    \n    # 2. 适用性检验\n    kmo_all, kmo_model = calculate_kmo(scaled_df)\n    bartlett_chisq, bartlett_p = calculate_bartlett_sphericity(scaled_df)\n    \n    # 3. 自动确定因子个数（若未指定）\n    if n_factors is None:\n        fa_temp = FactorAnalyzer(rotation=None)\n        fa_temp.fit(scaled_df)\n        eigenvalues, _ = fa_temp.get_eigenvalues()\n        n_factors = sum(eigenvalues > 1)\n        if n_factors < 1:\n            raise ValueError(\"所有特征值均小于1，无法提取有效公共因子\")\n    \n    # 4. 构建因子分析模型\n    fa = FactorAnalyzer(n_factors=n_factors, rotation=rotation, method='principal')\n    fa.fit(scaled_df)\n    \n    # 5. 获取因子载荷矩阵\n    factor_loadings = pd.DataFrame(\n        fa.loadings_,\n        index=data.columns,\n        columns=[f'因子{i+1}' for i in range(n_factors)]\n    )\n    \n    # 6. 因子方差解释信息\n    variance, variance_cumulative = fa.get_factor_variance()\n    factor_variance = pd.DataFrame({\n        '方差贡献率': variance,\n        '累积方差贡献率': variance_cumulative\n    }, index=[f'因子{i+1}' for i in range(n_factors)])\n    \n    # 7. 计算因子得分\n    factor_scores = pd.DataFrame(\n        fa.transform(scaled_df),\n        index=data.index,\n        columns=[f'因子{i+1}得分' for i in range(n_factors)]\n    )\n    \n    # 8. 计算综合得分（以方差贡献率为权重）\n    weights = variance / variance.sum()\n    comprehensive_scores = factor_scores @ weights\n    comprehensive_scores = pd.Series(comprehensive_scores, name='综合得分', index=data.index)\n    \n    # 9. 生成排名（从高到低）\n    ranking = comprehensive_scores.rank(ascending=False, method='min').astype(int)\n    ranking = pd.Series(ranking, name='排名', index=data.index)\n    \n    # 整理结果\n    results = {\n        'kmo_test': {'kmo_statistic': kmo_model, 'kmo_per_variable': kmo_all},\n        'bartlett_test': {'chi_square': bartlett_chisq, 'p_value': bartlett_p},\n        'factor_loadings': factor_loadings,\n        'factor_variance': factor_variance,\n        'factor_scores': factor_scores,\n        'comprehensive_scores': comprehensive_scores,\n        'ranking': ranking\n    }\n    \n    return results",
    "requirements": [
        "pandas",
        "numpy",
        "factor_analyzer",
        "scikit-learn"
    ],
    "examples_md_content": "# 因子分析综合评价使用示例\n\n## 示例1：学生成绩综合评价\n### 输入数据\n假设我们有5名学生的4门科目成绩：\n```python\nimport pandas as pd\n\ndata = pd.DataFrame({\n    '语文': [85, 78, 92, 70, 80],\n    '数学': [90, 82, 88, 65, 85],\n    '英语': [88, 80, 95, 72, 83],\n    '物理': [92, 75, 90, 68, 87]\n}, index=['学生A', '学生B', '学生C', '学生D', '学生E'])\n```\n\n### 调用方法\n```python\nfrom scripts.model import factor_analysis_comprehensive_evaluation\n\nresults = factor_analysis_comprehensive_evaluation(data)\n```\n\n### 预期输出\n1. **适用性检验**：\n   - KMO检验统计量约为0.82（适合因子分析）\n   - 巴特利特球形检验P值<0.05（拒绝原假设，数据适合因子分析）\n\n2. **因子提取**：自动提取2个公共因子\n   - 因子1载荷在语文、英语上较高（语言类因子）\n   - 因子2载荷在数学、物理上较高（理科类因子）\n\n3. **综合得分与排名**：\n   | 学生   | 综合得分 | 排名 |\n   |--------|----------|------|\n   | 学生C  | 1.52     | 1    |\n   | 学生A  | 0.87     | 2    |\n   | 学生E  | 0.23     | 3    |\n   | 学生B  | -0.61    | 4    |\n   | 学生D  | -2.01    | 5    |"
}