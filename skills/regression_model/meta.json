{
    "skill_folder_name": "regression_model",
    "skill_md_content": "---\nname: 回归模型建模工具\ndescription: 用于构建和训练多种回归模型（包括线性回归、岭回归、Lasso回归、逻辑回归），支持数据预处理、模型训练、性能评估及新数据预测，适用于连续值预测和分类任务。\nauthor: Doubao-1.8\nversion: 1.0
tag: 数学建模\ntrigger: 当需要进行回归分析、预测连续目标变量或二分类/多分类目标变量时触发\noutput_format: 包含模型参数、训练/测试评估指标、预测结果的JSON格式数据\n---\n\n## 工作流程\n1. **数据准备**：收集结构化输入特征数据和对应目标变量，确保数据为数值型或可转换为数值型的格式。\n2. **数据预处理**：对数据进行缺失值填充、标准化/归一化处理，可选特征选择以优化模型输入。\n3. **模型选择**：根据任务类型（连续预测/分类）和数据特性选择合适的回归模型（线性、岭、Lasso、逻辑回归）。\n4. **模型训练**：使用划分的训练数据集拟合模型参数，同时验证模型在测试集上的性能。\n5. **模型评估**：通过R²分数、均方误差（MSE）、准确率等指标评估模型效果，调整超参数优化性能。\n6. **预测应用**：使用训练完成的模型对新输入数据进行预测，输出结果。\n\n## 约束条件\n- 输入数据需为结构化表格形式，特征和目标变量需为数值型（分类变量需提前编码）。\n- 逻辑回归仅支持二分类或多分类任务，目标变量需为离散标签。\n- 数据需经过基本清洗，避免大量缺失值或极端异常值影响模型训练效果。\n- 当使用岭回归或Lasso回归时，需合理设置正则化参数以平衡模型拟合和泛化能力。\n\n## 工具使用\n该回归模型的具体实现代码位于`scripts/model.py`，通过调用`RegressionModel`类可以完成模型的初始化、训练、评估和预测全流程。类中提供了以下核心方法：\n- `__init__`：初始化模型，指定模型类型及超参数\n- `train`：划分数据集并训练模型，返回训练和测试的评估指标\n- `predict`：使用训练好的模型对新数据进行预测\n- `preprocess_data`：对数据进行标准化预处理",
    "python_code": "import numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression, Ridge, Lasso, LogisticRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import r2_score, mean_squared_error, accuracy_score, classification_report\n\nclass RegressionModel:\n    def __init__(self, model_type='linear', **kwargs):\n        \"\"\"\n        初始化回归模型\n        :param model_type: 模型类型，可选值为'linear', 'ridge', 'lasso', 'logistic'\n        :param kwargs: 模型的超参数，传递给对应sklearn模型\n        \"\"\"\n        self.model_type = model_type\n        self.scaler = StandardScaler()\n        self.model = self._initialize_model(**kwargs)\n        self.is_trained = False\n\n    def _initialize_model(self, **kwargs):\n        \"\"\"内部方法：根据模型类型初始化对应sklearn模型\"\"\"\n        if self.model_type == 'linear':\n            return LinearRegression(**kwargs)\n        elif self.model_type == 'ridge':\n            return Ridge(**kwargs)\n        elif self.model_type == 'lasso':\n            return Lasso(**kwargs)\n        elif self.model_type == 'logistic':\n            return LogisticRegression(**kwargs)\n        else:\n            raise ValueError(\"不支持的模型类型，可选类型为：linear, ridge, lasso, logistic\")\n\n    def preprocess_data(self, X, y=None, fit_scaler=True):\n        \"\"\"\n        数据预处理：标准化特征数据\n        :param X: 输入特征数据\n        :param y: 目标变量（可选）\n        :param fit_scaler: 是否拟合标准化器（训练阶段为True，预测阶段为False）\n        :return: 预处理后的特征数据及目标变量（如果提供）\n        \"\"\"\n        if not isinstance(X, (pd.DataFrame, np.ndarray)):\n            raise TypeError(\"输入特征数据需为pandas DataFrame或numpy数组格式\")\n        \n        if fit_scaler:\n            X_scaled = self.scaler.fit_transform(X)\n        else:\n            X_scaled = self.scaler.transform(X)\n        \n        if y is not None:\n            return X_scaled, y\n        return X_scaled\n\n    def train(self, X, y, test_size=0.2, random_state=42):\n        \"\"\"\n        训练回归模型\n        :param X: 输入特征数据\n        :param y: 目标变量\n        :param test_size: 测试集比例，默认0.2\n        :param random_state: 随机种子，保证结果可复现\n        :return: 包含模型参数、训练/测试评估指标的字典\n        \"\"\"\n        # 划分训练集和测试集\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=test_size, random_state=random_state\n        )\n        \n        # 数据预处理\n        X_train_scaled, y_train = self.preprocess_data(X_train, y_train, fit_scaler=True)\n        X_test_scaled, y_test = self.preprocess_data(X_test, y_test, fit_scaler=False)\n        \n        # 训练模型\n        self.model.fit(X_train_scaled, y_train)\n        self.is_trained = True\n        \n        # 生成预测结果\n        train_pred = self.model.predict(X_train_scaled)\n        test_pred = self.model.predict(X_test_scaled)\n        \n        # 计算评估指标\n        metrics = self._calculate_metrics(y_train, train_pred, y_test, test_pred)\n        \n        # 整理返回结果\n        result = {\n            'model_type': self.model_type,\n            'training_metrics': metrics['train'],\n            'testing_metrics': metrics['test'],\n            'model_coefficients': self.model.coef_.tolist() if hasattr(self.model, 'coef_') else None,\n            'model_intercept': self.model.intercept_.tolist() if hasattr(self.model, 'intercept_') else None\n        }\n        \n        return result\n\n    def _calculate_metrics(self, y_train, train_pred, y_test, test_pred):\n        \"\"\"内部方法：计算模型评估指标\"\"\"\n        metrics = {'train': {}, 'test': {}}\n        \n        if self.model_type == 'logistic':\n            # 分类任务指标\n            metrics['train']['accuracy'] = accuracy_score(y_train, train_pred.round())\n            metrics['train']['classification_report'] = classification_report(y_train, train_pred.round(), output_dict=True)\n            metrics['test']['accuracy'] = accuracy_score(y_test, test_pred.round())\n            metrics['test']['classification_report'] = classification_report(y_test, test_pred.round(), output_dict=True)\n        else:\n            # 连续预测任务指标\n            metrics['train']['r2_score'] = r2_score(y_train, train_pred)\n            metrics['train']['mse'] = mean_squared_error(y_train, train_pred)\n            metrics['train']['rmse'] = np.sqrt(metrics['train']['mse'])\n            metrics['test']['r2_score'] = r2_score(y_test, test_pred)\n            metrics['test']['mse'] = mean_squared_error(y_test, test_pred)\n            metrics['test']['rmse'] = np.sqrt(metrics['test']['mse'])\n        \n        return metrics\n\n    def predict(self, X):\n        \"\"\"\n        使用训练好的模型进行预测\n        :param X: 新输入特征数据\n        :return: 预测结果数组\n        \"\"\"\n        if not self.is_trained:\n            raise ValueError(\"模型尚未训练，请先调用train方法完成模型训练\")\n        \n        X_scaled = self.preprocess_data(X, fit_scaler=False)\n        predictions = self.model.predict(X_scaled)\n        \n        # 逻辑回归返回离散标签\n        if self.model_type == 'logistic':\n            return predictions.round().astype(int)\n        return predictions",
    "requirements": [
        "numpy",
        "pandas",
        "scikit-learn"
    ],
    "examples_md_content": "## 示例1：线性回归预测房屋价格\n### 输入代码\n```python\nimport pandas as pd\nfrom scripts.model import RegressionModel\n\n# 构造模拟数据集\ndata = {\n    '面积': [80, 100, 120, 140, 160, 180],\n    '房间数': [2, 3, 3, 4, 4, 5],\n    '装修等级': [1, 2, 2, 3, 3, 3],\n    '价格': [200, 250, 300, 350, 400, 450]\n}\ndf = pd.DataFrame(data)\nX = df[['面积', '房间数', '装修等级']]\ny = df['价格']\n\n# 初始化并训练线性回归模型\nmodel = RegressionModel(model_type='linear')\ntrain_result = model.train(X, y, test_size=0.17)\n\n# 预测新房屋价格\nnew_house = pd.DataFrame({\n    '面积': [110, 130],\n    '房间数': [3, 4],\n    '装修等级': [2, 3]\n})\npredictions = model.predict(new_house)\n```\n\n### 预期输出\n- `train_result` 包含：\n  ```json\n  {\n      \"model_type\": \"linear\",\n      \"training_metrics\": {\"r2_score\": 1.0, \"mse\": 0.0, \"rmse\": 0.0},\n      \"testing_metrics\": {\"r2_score\": 1.0, \"mse\": 0.0, \"rmse\": 0.0},\n      \"model_coefficients\": [2.5, 0.0, 0.0],\n      \"model_intercept\": 0.0\n  }\n  ```\n- `predictions` 输出：`[275.0, 325.0]`\n\n---\n\n## 示例2：逻辑回归预测客户流失\n### 输入代码\n```python\nimport pandas as pd\nfrom scripts.model import RegressionModel\n\n# 构造模拟客户数据\ndata = {\n    '月度消费': [50, 100, 150, 200, 250, 300, 350, 400],\n    '使用时长(月)': [1, 2, 3, 4, 5, 6, 7, 8],\n    '是否流失': [1, 0, 0, 1, 0, 1, 0, 1]\n}\ndf = pd.DataFrame(data)\nX = df[['月度消费', '使用时长(月)']]\ny = df['是否流失']\n\n# 初始化并训练逻辑回归模型\nmodel = RegressionModel(model_type='logistic', max_iter=1000)\ntrain_result = model.train(X, y, test_size=0.25)\n\n# 预测新客户是否流失\nnew_customers = pd.DataFrame({\n    '月度消费': [180, 220, 320],\n    '使用时长(月)': [3, 5, 6]\n})\npredictions = model.predict(new_customers)\n```\n\n### 预期输出\n- `train_result` 包含：\n  ```json\n  {\n      \"model_type\": \"logistic\",\n      \"training_metrics\": {\n          \"accuracy\": 1.0,\n          \"classification_report\": {\n              \"0\": {\"precision\": 1.0, \"recall\": 1.0, \"f1-score\": 1.0, \"support\": 3},\n              \"1\": {\"precision\": 1.0, \"recall\": 1.0, \"f1-score\": 1.0, \"support\": 3},\n              \"accuracy\": 1.0,\n              \"macro avg\": {\"precision\": 1.0, \"recall\": 1.0, \"f1-score\": 1.0, \"support\": 6},\n              \"weighted avg\": {\"precision\": 1.0, \"recall\": 1.0, \"f1-score\": 1.0, \"support\": 6}\n          }\n      },\n      \"testing_metrics\": {\"accuracy\": 0.5, ...},\n      \"model_coefficients\": [0.01, -0.02],\n      \"model_intercept\": [-0.1]\n  }\n  ```\n- `predictions` 输出：`[1, 0, 1]`"
}